
<!DOCTYPE html>
<html lang="en">

<head>
    <title>Sushobhan Parajuli</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Overpass+Mono:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.7/css/all.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">
</head>
<body>
    <header class="site-header">
        <nav class="nav">
            <div class="container flex-wrap">
                <h1 class="logo">
                    <a href="https://sushobhan55.github.io">Sushobhan Parajuli</a>
                </h1>
                <ul class="navbar">
                    <li><a href="index.html">About</a></li>
                    <li><a href="blog.html">Blog</a></li>
                    <li><a href="https://theticker.org/author/sushobhanparajuli/">The Ticker</a><li>
                    <li><a href="photography.html">Photography</a></li>
                    <li><a href="/images/Sushobhan-Parajuli-Resume.pdf">Resume</a></li>
                </ul>
            </div>
        </nav>
    </header>
    
  <div id="blog-list">
    <h3>Blog Posts:</h3>
  <ul>
    <li><a href="#blog1">Fine-tuning a LLM to build a customized chatbot.</a></li>
    <li><a href="#blog2">Portfolio optimization with python</a></li>
  </ul>
  </div>
    
    <article class="page container">
      <div class="page-content">
      <div class="blog-post">
      <div id="blog1">
        <div class="blog-heading">Fine-tuning a LLM to build a customized chatbot.</div>
          <div class="blog-date">August 22, 2022</div>
          <p>A large language model(LLM) is a deep learning model trained on enormous text data available on the internet. LLMs are a remarkable development in the field of Natural Language Processing as they are capable of language understanding and generation. Given a sequence of text, a LLM understands it and predicts the next token in the sequence. It uses an attention mechanism that allows it to highlight the most relevant information of the input text, and that’s how it understands the text. Then the model calculates probabilities of occurrence of different tokens that could follow the input sequence, and generates the token with the highest probability. A token can be a word or a character.
          <p>Some of the examples of LLMs are ELMo, Turing-NLG, Generative Pre-trained Transformer (GPT, GPT-2, and GPT-3), BERT, RoBERTa, and so on. These are very large and computationally expensive machine learning models and are developed by corporations and research groups. An individual may not build such a powerful model on their own, however they can fine-tune them on their data to get a desired model. One can fine-tune these pre-trained models on specific data to perform a downstream task, a task that you want to solve. Fine-tuning refers to re-training the pre-trained model on a custom data.
            <div align="center">
            <video width="500" height="300" autoplay muted>
                <source src="images/demo.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video>
            <p><a href="https://github.com/Sushobhan55/Peterson-Bot">Click for the github repository.</a>
            </div>
          <p>I built a chatbot that imitates Jordan Peterson. First, I created a dataset pretending I was talking to him and his responses are his actual words from either quora answers or interview transcripts. My responses are relevant to his responses and thus it builds up as a conversation. The dataset has in total 761 text messages, which is a small size data.
          <p>Next, I fine-tuned DialoGPT on the above dataset. DialoGPT is GPT-2 fine-tuned on conversation data. DialoGPT is an example of fine-tuned LLM to attain a downstream task, to serve as a conversational chatbot. Further fine-tuning on the above dataset makes it chat like Jordan Peterson.
          <p>Fine-tuning a pre-trained model works fine to make LLMs perform downstream tasks; however, if the data is large, it faces the same problem of being computationally expensive like training a new model. Recently, researchers have found that <a href="https://arxiv.org/pdf/2111.01998.pdf">prompt learning</a> is very effective in attaining downstream tasks, especially if it requires small data size. Prompt learning is a paradigm of providing LLMs with a carefully designed prompt, for example – descriptions of a task, so it performs that specific task.
     </div>
   <hr>
     <div id="blog2">   
          <p><div class="blog-heading">Portfolio optimization with python</div>
           <div class="blog-date">June 3, 2023</div>
          <strong><p>Efficient Frontier</strong>
          <p>Efficient frontier is a set of optimal portfolios that offer the highest expected return for a given level of risk or lowest risk for a given level of expected return.
          <p>Portfolio’s expected return is the sum of each product of an individual asset’s expected return with its respective weight in the overall portfolio.
          <p>Rp = ∑(Wi * Ri), where Rp = portfolio expected return,
                                     <p>Wi = weight of an individual asset, 
                                     <p>Ri = expected return of an individual asset.
          <p>Portfolio’s risk/volatility is gauged by its standard deviation, which is the square root of variance. Variance is a function of weights, variance and covariance. It is expressed as a dot product of matrices: 
              <p>σ2 = Wᵀ . V . W, where V = variance-covariance matrix,<p>W = matrix of individual asset weight,<p>Wᵀ = transpose of W.
          <strong><p>Stock Portfolio</strong> 
             <p>In python, I picked 20 different stocks across different industries to comprise a portfolio using <code>pandas_datareader</code>. Initially, I assigned 5% weight to each stock in order to observe the expected annual return and annual volatility of the portfolio without optimization. Then I calculated returns on each stock. Finally, I used the above formula (Rp) to calculate the annual portfolio return. Backtesting was done on the past five years of stock price data.
             <p>I calculated the annual variance-covariance matrix with an account that a typical year has 252 trading days. Then I used the above variance formula to calculate the portfolio’s variance, followed by its standard deviation.
          <p>The result was an expected annual return of <strong>34.0%</strong> and annual risk/volatility of 22.0%. This return and risk composition is suboptimal, and the initial portfolio is one of many suboptimal portfolios that lie below the efficient frontier. 
           <img src="images/EF.jpg" alt="Efficient Frontier" width="400" height="auto" align="center">
          <strong><p>Optimization with Python</strong>
                <p>I used <code>PyPortfolioOpt</code> to import <code>EfficientFrontier, risk_models, expected_returns, and objective_functions</code>. There is a detailed explanation of this package in its <a href="https://pyportfolioopt.readthedocs.io/en/latest/">documentation</a>. I calculated the expected return of the portfolio and the annualized sample covariance matrix of individual returns using the imported libraries. 
                <p>The next step was to optimize the Sharpe ratio. <strong>Sharpe ratio</strong> is the difference between the returns of the investment and the risk-free return, divided by the standard deviation of the investment. The higher sharpe ratio means that the return/risk relationship is more optimal.
                <p>In order to avoid many negligible positions, I set the parameter gamma more than 1 by using <code>objective_functions</code>. Higher gamma diversifies the portfolio. I cleaned the weights to get rid of non essential decimal digits.
          <div align="center"><p><a href="https://github.com/Sushobhan55/Algo/blob/master/Portfolio%20Optimizer.ipynb">Click here for the entire code.</a></p></div>
          <strong><p>Results</strong>
          <p>I was able to optimize my portfolio with an expected annual return <strong>59.1%</strong> for an annual volatility of 28.3%. The sharpe ratio was 2.02, which is a good measure. 
                <p>Discrete allocation of each stock was calculated by using individual weights of the optimized portfolio and an imaginative $1,000,000 portfolio amount.
          <strong><p>Implementation</strong>
                <p>An investor can implement this strategy to gain higher returns on their investments. They can customize the backtesting period, their portfolio stocks, and portfolio amount and finally get the discrete allocation of stocks in the optimized portfolio. I did the same with my portfolio in an investment challenge, and the result was impressive.
      </div>
    <hr>          
              
      </div>
      </div>
    </article>
    <p>
    <p>
    
    <footer class="site-footer">
        <div class="container">
            <small>
                    <b>Last Updated:</b> Jun 03, 2023
                </small>
            <small class="block">
                    © 2023 Sushobhan Parajuli · &lt;/&gt; Powered by <a href="https://jekyllrb.com/" target="_blank">Jekyll</a> and <a href="https://github.com/heiswayi/thinkspace" target="_blank">Thinkspace</a>; hosted on <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>.
                </small>
        </div>
    </footer>
</body>
</html>
